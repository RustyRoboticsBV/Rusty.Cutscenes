using Godot;

namespace Rusty.Cutscenes
{
    /// <summary>
    /// The meta-data for a cutscene instruction.
    /// </summary>
    [Tool]
    [GlobalClass]
    public sealed partial class InstructionDefinition : CutsceneResource
    {
        /* Public properties. */
        // Main.
        /// <summary>
        /// The opcode of this instruction. This is the main identifier of an instruction, used in the cutscene program files
        /// that the editor generates. Should be a short as possible. Make sure each instruction's opcode is fully unique!
        /// </summary>
        [Export] public string Opcode { get; private set; } = "";
        /// <summary>
        /// The parameters of this instruction.
        /// </summary>
        [Export] public ParameterDefinition[] Parameters { get; private set; } = new ParameterDefinition[0];

        // Runtime.
        /// <summary>
        /// The implementation of this instruction (in GDScript).
        /// </summary>
        [Export(PropertyHint.MultilineText)] public string Implementation { get; private set; } = "";

        // Meta data.
        /// <summary>
        /// The icon of this instruction, used in the cutscene editor.
        /// </summary>
        [Export] public Texture2D Icon { get; private set; }
        /// <summary>
        /// The human-readable name of this instruction that is used in the cutscene editor.
        /// </summary>
        [Export] public string DisplayName { get; private set; } = "";
        /// <summary>
        /// A description of this instruction. Used for documentation generation, and as a tooltip of the corresponding graph
        /// editor node, should this instruction have one.
        /// </summary>
        [Export(PropertyHint.MultilineText)] public string Description { get; private set; } = "";
        /// <summary>
        /// The category of the instruction. Gets used to group instructions together in the editor and documentation generation.
        /// </summary>
        [Export] public string Category { get; private set; } = "";

        // Editor.
        /// <summary>
        /// Contains information related to this instruction's graph node.
        /// When instantiated, this allows this instruction to be placed as a node in the cutscene graph editor.
        /// Leave this empty if this instruction should only appear as a pre-instruction of another instruction.
        /// </summary>
        [Export] public EditorNodeInfo EditorNode { get; private set; }
        /// <summary>
        /// If true, then the output will be hidden in the graph node editor, including if this instruction appears in
        /// another's compile rules.
        /// </summary>
        [Export] public bool HideDefaultOutput { get; private set; }
        /// <summary>
        /// A list of rules that tell the editor how to generate node previews.
        /// </summary>
        [Export] public PreviewTerm[] Preview { get; private set; } = new PreviewTerm[0];
        /// <summary>
        /// Defines what extra instructions can be generated by this instruction during cutscene compilation, and how
        /// they can be generated. These instructions will be generated before the main instruction, in the order of the array.
        /// </summary>
        [Export] public CompileRule[] CompileRules { get; private set; } = new CompileRule[0];

        /* Constructors. */
        public InstructionDefinition() { }

        public InstructionDefinition(string opcode, ParameterDefinition[] parameters,
            string implementation,
            Texture2D icon, string displayName, string description, string category,
            EditorNodeInfo editorNode, bool hideDefaultOutput, PreviewTerm[] preview, CompileRule[] compileRules)
        {
            Opcode = opcode;
            Parameters = parameters;
            Icon = icon;
            DisplayName = displayName;
            Description = description;
            Category = category;
            Implementation = implementation;
            EditorNode = editorNode;
            HideDefaultOutput = hideDefaultOutput;
            Preview = preview;
            CompileRules = compileRules;

            if (parameters == null)
                parameters = new ParameterDefinition[0];
            if (preview == null)
                preview = new PreviewTerm[0];
            if (compileRules == null)
                compileRules = new CompileRule[0];

            ResourceName = ToString();
        }

        /* Public methods. */
        public override string ToString()
        {
            // Add opcode.
            string str = Opcode + "(";

            // Add parameters.
            if (Parameters != null)
            {
                for (int i = 0; i < Parameters.Length; i++)
                {
                    if (i > 0)
                        str += ", ";
                    str += Parameters[i].Id;
                }
            }
            str += ")";

            return str;
        }

        public override bool Equals(object obj)
        {
            if (obj.GetType() == typeof(InstructionDefinition))
                return ((InstructionDefinition)obj).Opcode == Opcode;
            return false;
        }

        public override int GetHashCode()
        {
            return Opcode.GetHashCode();
        }

        /// <summary>
        /// Find the index of a parameter, using its name.
        /// </summary>
        public int GetParameterIndex(string id)
        {
            for (int i = 0; i < Parameters.Length; i++)
            {
                if (Parameters[i].Id == id)
                    return i;
            }
            return -1;
        }
    }
}